[
{
	"uri": "//localhost:1313/5-setup-api-gateway/5.1-create-api-primary-region/",
	"title": "Create API Gateway in Primary Region",
	"tags": [],
	"description": "",
	"content": "Create API Gateway in Primary Region (Singapore) In this step, we will create API Gateway in the Primary Region (Singapore ap-southeast-1) to provide REST API endpoints for frontend applications.\nContent Access API Gateway Console Create New REST API Configure Basic Information Create Resource read Create Resource write Create GET Method (for ReadFunction) Create POST Method (for WriteFunction) Enable CORS for Resource Deploy API Save the Invoke URL 1. Access API Gateway Console Sign in to AWS Management Console Ensure you are in Singapore (ap-southeast-1) Region Find and select API Gateway service 2. Create New REST API Choose Create API In the REST API section, choose Build (not Private REST API) 3. Configure Basic Information Choose the protocol: REST Create new API: New API API name: HighAvailabilityAPI Description: Primary Region API for Serverless Failover Endpoint Type: Regional Choose Create API 4. Create Resource read In the newly created API, choose Actions → Create Resource Resource Name: read Resource Path: /read Enable API Gateway CORS: ✅ (enable) Choose Create Resource 5. Create Resource write In the API, choose Actions → Create Resource Resource Name: write Resource Path: /write Enable API Gateway CORS: ✅ (enable) Choose Create Resource 6. Create GET Method (for ReadFunction) Select the /read resource just created Choose Actions → Create Method From dropdown, select GET and click ✅ Configure Integration:\nIntegration type: Lambda Function Use Lambda Proxy integration: ✅ (enable) Lambda Region: ap-southeast-1 Lambda Function: ReadFunction Choose Save 7. Create POST Method (for WriteFunction) Select the /write resource Choose Actions → Create Method From dropdown, select POST and click ✅ Configure Integration:\nIntegration type: Lambda Function Use Lambda Proxy integration: ✅ (enable) Lambda Region: ap-southeast-1 Lambda Function: WriteFunction Choose Save 8. Enable CORS for Resource Select the root resource / Choose Actions → Enable CORS Configure CORS:\nAccess-Control-Allow-Origin: * Access-Control-Allow-Headers: Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token 9. Deploy API Choose Actions → Deploy API Deployment stage: [New Stage] Stage name: prod Stage description: Production stage for Primary Region Deployment description: Initial deployment Choose Deploy 10. Save the Invoke URL After successful deployment, in the Stages → prod tab, you will see the Invoke URL:\nhttps://xxxxxxxxxx.execute-api.ap-southeast-1.amazonaws.com/prod Save this URL - we will need it to:\nTest API functionality Configure Route 53 health checks Integrate with frontend application "
},
{
	"uri": "//localhost:1313/6-setup-dns-route53-failover/6.1-setup-dns-delegation/",
	"title": "DNS Delegation for api.turtleclouds.id.vn",
	"tags": [],
	"description": "",
	"content": "DNS Delegation for api.turtleclouds.id.vn To properly implement Step 6 (Route 53 health check + failover), we only need to delegate DNS authority for the api subdomain to Route 53, while keeping the root domain turtleclouds.id.vn with Cloudflare.\nWhy DNS Delegation is Needed? Separate Management: API subdomain managed by Route 53, main domain stays with Cloudflare Health Check: Route 53 can perform health checks and failover for API endpoints Flexibility: No impact on other subdomains (www, mail, etc.) AWS Integration: Better integration with other AWS services Content Create Route 53 Hosted Zone Save NS Records Configure NS Records on Cloudflare Verify DNS Delegation 1. Create Route 53 Hosted Zone Access Route 53 in AWS Console Choose Hosted zones → Create hosted zone Configure Hosted Zone:\nDomain name: api.turtleclouds.id.vn Type: Public hosted zone Comment: Subdomain for API Gateway failover Choose Create hosted zone 2. Save NS Records After creating the hosted zone, Route 53 will provide 4 NS (Name Server) records. Save these NS records:\nns-xxxx.awsdns-xx.org\rns-xxxx.awsdns-xx.net\rns-xxxx.awsdns-xx.com\rns-xxxx.awsdns-xx.co.uk Note: Your NS records will be different from the example above. Make sure to copy the exact NS records that Route 53 provides for your hosted zone.\n3. Configure NS Records on Cloudflare Sign in to Cloudflare Dashboard Select domain turtleclouds.id.vn Go to DNS → Records Add NS Records:\nCreate 4 NS records, one for each Route 53 NS server:\nRecord 1:\nType: NS Name: api Content: ns-xxxx.awsdns-xx.org TTL: Auto Record 2:\nType: NS Name: api Content: ns-xxxx.awsdns-xx.net TTL: Auto Record 3:\nType: NS Name: api Content: ns-xxxx.awsdns-xx.com TTL: Auto Record 4:\nType: NS Name: api Content: ns-xxxx.awsdns-xx.co.uk TTL: Auto Important: Ensure Proxy status is DNS only (gray cloud), not Proxied (orange cloud) for NS records.\n4. Verify DNS Delegation After configuration, verify that DNS delegation is working:\nUsing nslookup:\nnslookup -type=NS api.turtleclouds.id.vn Expected result:\nServer: 8.8.8.8\rAddress: 8.8.8.8#53\rNon-authoritative answer:\rapi.turtleclouds.id.vn nameserver = ns-xxxx.awsdns-xx.org.\rapi.turtleclouds.id.vn nameserver = ns-xxxx.awsdns-xx.net.\rapi.turtleclouds.id.vn nameserver = ns-xxxx.awsdns-xx.com.\rapi.turtleclouds.id.vn nameserver = ns-xxxx.awsdns-xx.co.uk. Using dig (Linux/Mac):\ndig NS api.turtleclouds.id.vn Results After completing this step:\n✅ Route 53 Hosted Zone created for api.turtleclouds.id.vn ✅ NS Records configured on Cloudflare ✅ DNS Delegation working correctly ✅ Subdomain api now managed by Route 53 Preparation for Next Step From now on, all DNS records for *.api.turtleclouds.id.vn will be managed by Route 53, while the rest (www, root, etc.) remain with Cloudflare as before.\nIn the next step, we will create SSL certificates for this domain using AWS Certificate Manager.\n"
},
{
	"uri": "//localhost:1313/1-create-new-aws-account/1.1-find-account-id/",
	"title": "Domain Registration at TENTEN.VN",
	"tags": [],
	"description": "",
	"content": "First, you need to register a domain on the tenten.vn website. After accessing the official website, search for the domain you desire, for example turtleclouds.id.vn. If this domain is still available, you can proceed with registration by filling in complete personal or business information, then making an online payment. Immediately after completion, the system will send you domain management information via email, allowing you full control over DNS records as well as Nameserver settings.\nContent Access TENTEN.VN homepage Check domain registration status Verify domain status 1. Go to tenten.vn homepage or watch the tutorial video via this link Register domain and free hosting from tenten.vn 2. After successful domain registration, you can check following these steps Click following the image instructions You will see your registered domain and the active status is successful Note: The process from domain registration to receiving successful confirmation email can take up to 1 day.\n"
},
{
	"uri": "//localhost:1313/2-mfa-setup-for-aws-user-root/1-virtual-mfa-device/",
	"title": "Enable Global Tables and Add Secondary Region",
	"tags": [],
	"description": "",
	"content": "Amazon DynamoDB Global Tables Amazon DynamoDB Global Tables is a feature that enables automatic multi-Region data replication. When you enable Global Tables, data written in one Region is automatically replicated to other Regions following a multi-active model (both Regions can read/write).\nThis helps applications achieve:\nHigh Availability: If one Region experiences an outage, the application can still access data from the remaining Region. Disaster Recovery (DR): Ensures data is not interrupted and can be recovered quickly. Global Performance: Users in different regions can access data from the nearest Region to reduce latency. In this lab, after creating the DynamoDB table in the primary Region (e.g., us-east-1), you will enable Global Tables to create a replica in the secondary Region (us-west-2). When completed, any changes to the table in one Region will be synchronized in near real-time to the table in the other Region.\nStep 2: Enable Global Tables and Add Secondary Region 1. After completing the first step, next we will click on the newly created HighAvailabilityTable 2. In the newly created table, navigate to the Global Tables tab 3. Choose Create replica → select backup Region (e.g., Tokyo ap-northeast-1) 4. After creation, we will wait 3-5 minutes for resource initialization. Finally, when you see \u0026ldquo;Replica\u0026rdquo; change to Status Active, it is successful "
},
{
	"uri": "//localhost:1313/1-create-new-aws-account/",
	"title": "Preparation Steps",
	"tags": [],
	"description": "",
	"content": "Preparation for Serverless Failover Architecture Before starting to build the Serverless Failover architecture, we need to prepare some basic components:\nPrerequisites AWS Account: Ensure you have an AWS account with Administrator permissions Domain Name: Prepare a domain name for Route 53 configuration (optional) Basic Knowledge: Understanding of basic AWS services Regions to be used In this lab, we will use 2 Regions:\nPrimary Region: Singapore (ap-southeast-1) Secondary Region: Tokyo (ap-northeast-1) Architecture Overview We will build a serverless application with automatic failover capability including:\nDynamoDB Global Tables: Data storage synchronized between Regions Lambda Functions: Backend logic processing API Gateway: REST API endpoints Route 53: DNS failover and health checks S3: Static website hosting Content:\nDomain Registration at TENTEN.VN Hosting on DATAONLINE.VN Using Cloudflare for Domain Management "
},
{
	"uri": "//localhost:1313/",
	"title": "Serverless Failover: DynamoDB, Lambda, API Gateway &amp; Route 53",
	"tags": [],
	"description": "",
	"content": "Serverless Failover: DynamoDB, Lambda, API Gateway \u0026amp; Route 53 Overview In production environments, one of the biggest risks is downtime when an AWS Region experiences an outage. For applications that require High Availability (HA) and Disaster Recovery (DR) capabilities, implementing multi-Region infrastructure is a critical strategy.\nIn this lab, you will build a multi-Region serverless application with the ability to:\nFault-Tolerant: The application continues to operate normally when a component fails. Disaster Recovery (DR): If the Primary Region goes down, the system automatically switches to the Secondary Region without service interruption for end users. The main goal is to combine multiple AWS serverless services to form a comprehensive, secure, and automatic failover architecture.\nArchitecture Overview Key Architecture Components 1. Amazon DynamoDB Global Tables Role: Primary data storage system for the application following a multi-region, multi-active model.\nHow it works: All data written in one Region is automatically synchronized to other Regions within seconds (e.g., Singapore ↔ Tokyo).\nDR Benefits: When the Primary Region fails, the Secondary Region still has the latest data to serve users, avoiding data loss (zero data loss) and maintaining continuity.\n2. AWS Lambda (Python Functions) Role: Provides serverless backend processing layer without infrastructure management.\nHow it works: Lambda functions are deployed in parallel across both Regions, responsible for reading and writing data from DynamoDB. When users call the API, Lambda executes logic and returns results immediately.\nDR Benefits: Since Lambda is serverless, AWS automatically ensures availability across both Regions. When Route 53 redirects requests, Lambda in the remaining Region continues processing without manual configuration changes.\n3. Amazon API Gateway Role: Acts as RESTful API gateway, connecting clients and Lambda.\nHow it works: API Gateway is deployed in both Primary and Secondary Regions, providing unified endpoints (stage /prod). It also supports logging and throttling for request control.\nDR Benefits: Users don\u0026rsquo;t need to know which Region the API is running in. When failover occurs, Route 53 automatically switches DNS to the Secondary Region\u0026rsquo;s API Gateway, providing seamless experience.\n4. Amazon Route 53 Role: Manages DNS and performs failover based on health checks.\nHow it works: You configure DNS records for your domain (e.g., api.example.com) pointing to API Gateway in the Primary Region, and failover records pointing to the Secondary. Route 53 continuously monitors the primary endpoint and redirects to the remaining Region if it detects failures.\nDR Benefits: Redirection is completely automatic, ensuring zero downtime and minimizing service interruption risks for users.\n5. AWS Certificate Manager (ACM) Role: Issues and manages SSL/TLS certificates for custom domains.\nHow it works: ACM issues free certificates, which are then attached to API Gateway Custom Domain to enable HTTPS.\nDR Benefits: Ensures all client requests to the API are always secured via HTTPS, complying with security standards and building user trust.\n6. Amazon S3 (Frontend Website Hosting) Role: Stores and serves static websites (HTML, CSS, JS).\nHow it works: Frontend website is hosted on an S3 bucket, can be combined with CloudFront for acceleration. This website calls APIs through the domain configured with Route 53.\nDR Benefits: Since the frontend is served from a static and stable source, when backend failover occurs, the website continues to function normally. Users continue using without changing any URLs.\nMain Content Preparation Steps Create DynamoDB Table in Primary Region Create IAM Role for Lambda Functions Create Lambda Functions in Both Regions Set Up API Gateway (Both Regions) Set Up DNS Route 53 and Configure Failover for API Gateway Create the Frontend Website Test the failover mechanism by deleting the API in the primary (Singapore) Clean Up Resources "
},
{
	"uri": "//localhost:1313/6-setup-dns-route53-failover/6.2-acm-ssl-certificates/",
	"title": "ACM DNS validation for both regions",
	"tags": [],
	"description": "",
	"content": "ACM DNS validation for both regions Since you\u0026rsquo;re using Regional APIs in ap-southeast-1 (Singapore – primary) and ap-northeast-1 (Tokyo – secondary), you need 2 certificates, one in each corresponding region.\nWhy SSL Certificates are Needed for Both Regions? Regional Requirement: API Gateway Regional endpoints need certificates in the same Region Custom Domain: To use custom domain instead of default AWS URLs HTTPS Security: Ensure all API calls are encrypted Failover Support: Both Regions need SSL for failover to work Content Create Certificate for Singapore Region DNS Validation for Singapore Create Certificate for Tokyo Region DNS Validation for Tokyo Check Certificate Status 1. Create Certificate for Singapore Region Ensure you are in Singapore (ap-southeast-1) Region Access AWS Certificate Manager (ACM) Choose Request a certificate Configure Certificate:\nCertificate type: Request a public certificate Choose Next Domain names:\nFully qualified domain name: api.turtleclouds.id.vn If you need SAN (Subject Alternative Names): www.api.turtleclouds.id.vn Validation method: DNS validation Key algorithm: RSA 2048 Choose Request 2. DNS Validation for Singapore ACM will display validation information. You will see a CNAME record that needs to be created:\nExample CNAME record:\nName: _4724b28c2f251eaf0f8e5de086a13395.api.turtleclouds.id.vn Value: _d527ab199f33beee1a7c9dedf48c932a.xlfgrmvvlj.acm-validations.aws 👉 In ACM interface, choose Create records in Route 53 to create automatically. Create DNS record in Route 53 When you click the button, ACM will open the DNS record creation interface in Route 53.\nDomain: api.turtleclouds.id.vn\nValidation status: Pending validation\nChoose Create records to confirm. Verify status After creation, return to the certificate details screen in ACM.\nStatus will be Pending validation.\nAfter a few minutes, when DNS propagation is complete, ACM will automatically change to Issued. Note: Since subdomain api.* has been delegated to Route 53, you create the CNAME record directly in Route 53 (zone: api.turtleclouds.id.vn), no need to work with Cloudflare.\n3. Create Certificate for Tokyo Region Switch to Tokyo (ap-northeast-1) Region Access AWS Certificate Manager (ACM) Repeat the same steps as Singapore Configure Certificate:\nDomain name: api.turtleclouds.id.vn Validation method: DNS validation Key algorithm: RSA 2048 Choose Request 4. DNS Validation for Tokyo ACM Tokyo will provide a different CNAME record for validation:\nExample CNAME record for Tokyo:\nName: _8956c39d4e362bfb2c9f7a180b24567e.api.turtleclouds.id.vn Value: _f638bc210e44ceef2d8d0f57f49c843b.ylfgrmvvlj.acm-validations.aws 👉 In ACM interface, choose Create records in Route 53 to create automatically.\nCreate DNS record in Route 53 When you click the button, ACM will open the DNS record creation interface in Route 53.\nDomain: api.turtleclouds.id.vn\nValidation status: Pending validation\nChoose Create records to confirm.\nVerify status After creation, return to the certificate details screen in ACM.\nStatus will be Pending validation.\nAfter a few minutes, when DNS propagation is complete, ACM will automatically change to Issued.\nNote: Since subdomain api.* has been delegated to Route 53, you create the CNAME record directly in Route 53 (zone: api.turtleclouds.id.vn), no need to work with Cloudflare.\n5. Check Certificate Status Check Singapore Certificate:\nReturn to ACM in Singapore Region Wait for status to change from Pending validation → Issued (usually 2-10 minutes) Check Tokyo Certificate:\nSwitch to ACM in Tokyo Region Wait for status to change from Pending validation → Issued Troubleshooting If certificates are not issued after 15 minutes:\nCheck CNAME records: Ensure they are created correctly in Route 53 Check DNS propagation: Use nslookup to verify Check TTL: Ensure TTL is not too high (recommended 300s) nslookup -type=CNAME _4724b28c2f251eaf0f8e5de086a13395.api.turtleclouds.id.vn Results After completing this step:\n✅ SSL Certificate issued for Singapore Region ✅ SSL Certificate issued for Tokyo Region ✅ DNS Validation working correctly ✅ CNAME Records created in Route 53 Preparation for Next Step With 2 SSL certificates ready, we can create Custom Domain Names for API Gateway in both Regions in the next step.\n"
},
{
	"uri": "//localhost:1313/2-mfa-setup-for-aws-user-root/",
	"title": "Create DynamoDB Table in Primary Region",
	"tags": [],
	"description": "",
	"content": "Introduction to DynamoDB Amazon DynamoDB is a fully managed NoSQL database service that provides key-value and document data storage with single-digit millisecond latency at any scale. The major advantages of DynamoDB are auto scaling, no server management required, and built-in security, backup, and caching features.\nIn this lab, DynamoDB serves as the primary data storage foundation for the application, ensuring data is automatically replicated between multiple Regions through Global Tables, helping the application maintain availability and consistency even when a Region experiences an outage.\nContent Create DynamoDB Table in Primary Region Enable Global Tables and Add Secondary Region Step 1: Create DynamoDB Table in Primary Region 1. Sign in to the AWS Management Console 2. Navigate to the DynamoDB service 3. Create a new table in the primary region (e.g., ap-southeast-1) Table name: HighAvailabilityTable\nPartition key: ItemId (String)\n4. Select \u0026ldquo;Default Settings\u0026rdquo; in the Table Settings section 5. Finally, choose \u0026ldquo;Create table\u0026rdquo; Wait approximately 2-3 minutes for resource initialization. Check that the Status changes to \u0026ldquo;Active\u0026rdquo; for success "
},
{
	"uri": "//localhost:1313/1-create-new-aws-account/1.2-update-account/",
	"title": "Hosting on DATAONLINE.VN",
	"tags": [],
	"description": "",
	"content": "Next, you need to prepare a hosting service on DataOnline to store and operate your website. When you register for a suitable hosting package, the provider will send you the server IP address along with cPanel or Plesk admin login information.\nContent Access DataOnline homepage Register hosting package Login to Control Panel DNS Management Create DNS Records 1. Go to dataonline.vn homepage or watch the tutorial video via this link Free hosting, quality like paid hosting, free host without ads at Dataonline 2. After registering the hosting package, we will create the records 3. Click next to login to Control Panel Click once more to login to Control Panel 4. Next we click on DNS Management 5. Finally we create the 2 records First, create an A record for the root domain (symbol @), pointing to the server IP address provided by DataOnline. Then, continue to create another A record for the www prefix, also pointing to the same hosting IP. These two records will ensure that when users enter turtleclouds.id.vn or www.turtleclouds.id.vn in their browser, the system will correctly direct them to the website hosted on DataOnline.\n"
},
{
	"uri": "//localhost:1313/5-setup-api-gateway/5.2-create-api-secondary-region/",
	"title": "Replicate API Gateway to Secondary Region",
	"tags": [],
	"description": "",
	"content": "Replicate API Gateway to Secondary Region (Tokyo) In this step, we will create a similar API Gateway in the Secondary Region (Tokyo ap-northeast-1) to ensure high availability and failover capability.\nWhy Replicate API Gateway? High Availability: If Primary Region fails, Secondary Region can still serve requests Disaster Recovery: Ensures zero downtime when failover occurs Performance: Users in Asia region can access from a closer Region Load Distribution: Distributes load between Regions Content Switch to Secondary Region Create Similar API Gateway as Step 5.1 Access API Gateway Console Create New REST API Configure Basic Information Create Resource read Create Resource write Create GET Method (for ReadFunction) Create POST Method (for WriteFunction) Enable CORS for Resource Deploy API Save the Invoke URL 1. Switch to Secondary Region In AWS Console, switch Region from Singapore to Tokyo (ap-northeast-1) Access API Gateway service 2. Create Similar API Gateway as Step 5.1 3. Access API Gateway Console Sign in to AWS Management Console Ensure you are in Tokyo (ap-northeast-1) Region Find and select API Gateway service 4. Create New REST API Choose Create API In the REST API section, choose Build (not Private REST API) 5. Configure Basic Information Choose the protocol: REST Create new API: New API API name: HighAvailabilityAPI Description: Secondary Region API for Serverless Failover Endpoint Type: Regional Choose Create API 6. Create Resource read In the newly created API, choose Actions → Create Resource Resource Name: read Resource Path: /read Enable API Gateway CORS: ✅ (enable) Choose Create Resource 7. Create Resource write In the API, choose Actions → Create Resource Resource Name: write Resource Path: /write Enable API Gateway CORS: ✅ (enable) Choose Create Resource 8. Create GET Method (for ReadFunction) Select the /read resource just created Choose Actions → Create Method From dropdown, select GET and click ✅ Configure Integration:\nIntegration type: Lambda Function Use Lambda Proxy integration: ✅ (enable) Lambda Region: Tokyo (ap-northeast-1) Lambda Function: ReadFunction Choose Save 9. Create POST Method (for WriteFunction) Select the /write resource Choose Actions → Create Method From dropdown, select POST and click ✅ Configure Integration:\nIntegration type: Lambda Function Use Lambda Proxy integration: ✅ (enable) Lambda Region: Tokyo (ap-northeast-1) Lambda Function: WriteFunction Choose Save 10. Enable CORS for Resource Select the root resource / Choose Actions → Enable CORS Configure CORS:\nAccess-Control-Allow-Origin: * Access-Control-Allow-Headers: Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token 11. Deploy API Choose Actions → Deploy API Deployment stage: [New Stage] Stage name: prod Stage description: Production stage for Secondary Region Deployment description: Initial deployment Choose Deploy 12. Save the Invoke URL After successful deployment, in the Stages → prod tab, you will see the Invoke URL:\nhttps://xxxxxxxxxx.execute-api.ap-northeast-1.amazonaws.com/prod Save this URL - we will need it to:\nTest API functionality Configure Route 53 health checks Integrate with frontend application "
},
{
	"uri": "//localhost:1313/6-setup-dns-route53-failover/6.3-api-gateway-custom-domains/",
	"title": "Create Custom domains for API Gateway (one per region)",
	"tags": [],
	"description": "",
	"content": "Create Custom domains for API Gateway (one per region) After having SSL certificates in both Regions, we will create Custom Domain Names for API Gateway to use custom domain instead of default AWS URLs.\nWhy Custom Domain is Needed? Professional URL: Use api.turtleclouds.id.vn instead of long AWS URLs SSL/TLS: Enable HTTPS with custom certificate Branding: Consistent with brand and main domain Failover Ready: Prepare for Route 53 failover configuration Content Create Custom Domain for Singapore Region Configure API Mapping for Singapore Save Regional Domain Name Singapore Create Custom Domain for Tokyo Region Configure API Mapping for Tokyo Save Regional Domain Name Tokyo 1. Create Custom Domain for Singapore Region Ensure you are in Singapore (ap-southeast-1) Region Access API Gateway → Custom domain names Choose Add domain names Configure Custom Domain:\nDomain name: api.turtleclouds.id.vn Endpoint type: Regional ACM certificate: Select Issued certificate from Singapore Region Security policy: TLS 1.2 Choose Add domain name 2. Configure API Mapping for Singapore After creating custom domain, need to map with API Gateway:\nIn the newly created custom domain, select API mappings tab Choose Configure API mappings Add API Mapping:\nChoose Add new mapping API: Select HighAvailabilityAPI Stage: prod Path: leave empty (root path) Choose Save 3. Save Regional Domain Name Singapore After creating custom domain, API Gateway will generate a Regional domain name. Save this information:\nExample Regional Domain Name:\nd-a7cx5xv22d.execute-api.ap-southeast-1.amazonaws.com Important: This Regional domain name will be used in Route 53 to create ALIAS records for failover.\n4. Create Custom Domain for Tokyo Region Switch to Tokyo (ap-northeast-1) Region Access API Gateway → Custom domain names Choose Add domain names Configure Custom Domain:\nDomain name: api.turtleclouds.id.vn Endpoint type: Regional ACM certificate: Select Issued certificate from Tokyo Region Security policy: TLS 1.2 Choose Add domain name 5. Configure API Mapping for Tokyo In Tokyo custom domain, select API mappings tab Choose Configure API mappings Add API Mapping:\nChoose Add new mapping API: Select HighAvailabilityAPI Stage: prod Path: leave empty (root path) Choose Save 6. Save Regional Domain Name Tokyo Save the Regional domain name for Tokyo:\nExample Regional Domain Name Tokyo:\nd-b8dy6yw33e.execute-api.ap-northeast-1.amazonaws.com Results After completing this step:\n✅ Custom Domain created for Singapore Region ✅ Custom Domain created for Tokyo Region ✅ API Mappings configured for both Regions ✅ Regional Domain Names saved for use in Route 53 Information to Save Region Custom Domain Regional Domain Name Certificate Singapore api.turtleclouds.id.vn d-pbm3eqaneb.execute-api.ap-southeast-1.amazonaws.com ACM Singapore Tokyo api.turtleclouds.id.vn d-15ro7mhib1.execute-api.ap-northeast-1.amazonaws.com ACM Tokyo Preparation for Next Step With Custom Domains ready, we can create Route 53 Health Checks and Failover Records in the final step.\n"
},
{
	"uri": "//localhost:1313/3-create-admin-user-and-group/",
	"title": "Create IAM Role for Lambda Functions",
	"tags": [],
	"description": "",
	"content": "In AWS, IAM Role is like a \u0026ldquo;permission set\u0026rdquo; that is predefined. A Role is not permanently attached to a specific user, but is temporarily \u0026ldquo;borrowed\u0026rdquo; by AWS services or applications to have permission to perform actions.\nExample:\nAWS Lambda needs a Role to have permission to read/write data to DynamoDB.\nEC2 Instance can be assigned a Role to access S3 without storing Access Key/Secret Key in the machine.\nDifference compared to IAM User:\nUser: attached to an individual or application, has username \u0026amp; password or access key.\nRole: has no separate login information, only grants temporary permissions to services or users/applications that assume it.\n👉 In this lab, you will create a Role named LambdaDynamoDBRole to allow Lambda Functions to:\nAccess DynamoDB. Write logs to CloudWatch. Content Open IAM Console Create New Role for Lambda Assign Permissions to Role Name and Create Role Save Role ARN Create IAM Role for Lambda Functions 1. Open IAM Console Sign in to AWS Management Console. Find and select the IAM service. 2. Create New Role for Lambda Choose Roles → Create role. In the Trusted entity type section, select AWS Service. Select the Lambda service, then click Next. 3. Assign Permissions to Role Find and select 2 policies: AmazonDynamoDBFullAccess → allows Lambda to interact with DynamoDB. AWSLambdaBasicExecutionRole → allows Lambda to write logs to CloudWatch. Click Next 4. Name and Create Role Enter Role name: LambdaDynamoDBRole. Click Create role to complete. You have successfully created the Role 5. Save Role ARN After creation, open the Role details. Copy the Role ARN (will be needed when assigning to Lambda function later). "
},
{
	"uri": "//localhost:1313/1-create-new-aws-account/1.3-aws-account-alias/",
	"title": "Using Cloudflare for Domain Management",
	"tags": [],
	"description": "",
	"content": "After pointing the domain turtleclouds.id.vn to the hosting IP address on DataOnline, the next step is to use Cloudflare to manage and optimize the domain. Cloudflare acts as an intermediary layer between users and the server, helping to increase access speed through a global CDN system, while enhancing security with firewall and DDoS attack protection. First, you need to create a free account at dash.cloudflare.com and add the domain turtleclouds.id.vn to the system. Cloudflare will automatically scan and import existing DNS records, while providing you with two new Nameservers.\nContent Log in to Cloudflare and enter domain Configure DNS Records Update Nameserver at tenten.vn Final verification Step 1: Log in to Cloudflare and enter the registered domain, here for example turtleclouds.id.vn Step 2: Go to the control panel, select DNS then select Records. Next, choose Add records to add 2 records Step 3: Update Nameserver at tenten.vn Next, you log in to the domain management page at tenten.vn, find the Nameserver Management section and change the default Nameservers to the two addresses that Cloudflare just provided. Save the changes and wait for the system to update. Go to Actions then select NS Settings Replace the 2 NS records of tenten.vn with the 2 NS records of Cloudflare and click Update Step 4: Final verification step After configuring Nameserver at tenten.vn and completing DNS setup on Cloudflare, open Command Prompt or PowerShell on your computer and use the command: ping turtleclouds.id.vn Result "
},
{
	"uri": "//localhost:1313/4-verify-new-account/",
	"title": "Create Lambda Functions in Both Regions",
	"tags": [],
	"description": "",
	"content": "Introduction to Amazon Lambda AWS Lambda is AWS\u0026rsquo;s serverless compute service. With Lambda, you can run code without managing servers – just write code, upload it, and AWS automatically handles resource provisioning, scaling, and billing based on function invocations.\nKey characteristics:\nNo infrastructure management → AWS operates the entire backend. Automatic scaling → Lambda can handle from a few requests to thousands of requests per second. Tight integration with other AWS services (DynamoDB, S3, API Gateway, etc.). Lambda Function Role in This Step\nIn this lab, Lambda serves as the application logic layer between API Gateway and DynamoDB:\nReadFunction: reads all data from the DynamoDB table and returns results in JSON format.\nWriteFunction: receives data from requests (via API Gateway), then writes (put item) to DynamoDB.\nIn this step, we will create Lambda Functions to handle backend logic for the application in both Regions (Primary and Secondary).\nContent Open AWS Lambda Console Create Lambda Function for Reading Data (ReadFunction) Create Lambda Function for Writing Data (WriteFunction) Deploy Functions in Secondary Region 1. Open AWS Lambda Console Sign in to AWS Management Console. Find and select the Lambda service. 2. Create Lambda Function for Reading Data (ReadFunction) Choose Create function. Enter configuration: Function name: ReadFunction Runtime: Python 3.9 Execution role: Choose Use an existing role and select LambdaDynamoDBRole (created in previous step). Execution role: Choose Use an existing role and select LambdaDynamoDBRole (created in previous step).\nCopy the following code and paste it into lambda_function.py:\nimport json import boto3 from boto3.dynamodb.conditions import Key from decimal import Decimal # Initialize DynamoDB resource dynamodb = boto3.resource(\u0026#39;dynamodb\u0026#39;) table = dynamodb.Table(\u0026#39;HighAvailabilityTable\u0026#39;) # Helper function to convert Decimal to regular types for JSON serialization def decimal_default(obj): if isinstance(obj, Decimal): return float(obj) raise TypeError def lambda_handler(event, context): # Handle preflight OPTIONS request for CORS if event.get(\u0026#39;httpMethod\u0026#39;) == \u0026#39;OPTIONS\u0026#39;: return { \u0026#39;statusCode\u0026#39;: 200, \u0026#39;headers\u0026#39;: { \u0026#39;Access-Control-Allow-Origin\u0026#39;: \u0026#39;*\u0026#39;, \u0026#39;Access-Control-Allow-Methods\u0026#39;: \u0026#39;GET, POST, OPTIONS\u0026#39;, \u0026#39;Access-Control-Allow-Headers\u0026#39;: \u0026#39;Content-Type, Authorization\u0026#39;, \u0026#39;Access-Control-Max-Age\u0026#39;: \u0026#39;86400\u0026#39; }, \u0026#39;body\u0026#39;: \u0026#39;\u0026#39; } try: # Scan the table to get all items response = table.scan() items = response[\u0026#39;Items\u0026#39;] # Handle pagination if there are more items while \u0026#39;LastEvaluatedKey\u0026#39; in response: response = table.scan(ExclusiveStartKey=response[\u0026#39;LastEvaluatedKey\u0026#39;]) items.extend(response[\u0026#39;Items\u0026#39;]) # Sort items by ItemId for consistent ordering items.sort(key=lambda x: str(x.get(\u0026#39;ItemId\u0026#39;, \u0026#39;\u0026#39;))) return { \u0026#39;statusCode\u0026#39;: 200, \u0026#39;headers\u0026#39;: { \u0026#39;Content-Type\u0026#39;: \u0026#39;application/json\u0026#39;, \u0026#39;Access-Control-Allow-Origin\u0026#39;: \u0026#39;*\u0026#39;, \u0026#39;Access-Control-Allow-Methods\u0026#39;: \u0026#39;GET, POST, OPTIONS\u0026#39;, \u0026#39;Access-Control-Allow-Headers\u0026#39;: \u0026#39;Content-Type, Authorization\u0026#39;, \u0026#39;Cache-Control\u0026#39;: \u0026#39;no-cache, no-store, must-revalidate\u0026#39;, \u0026#39;Pragma\u0026#39;: \u0026#39;no-cache\u0026#39;, \u0026#39;Expires\u0026#39;: \u0026#39;0\u0026#39; }, \u0026#39;body\u0026#39;: json.dumps(items, default=decimal_default, ensure_ascii=False) } except Exception as e: print(f\u0026#34;Error reading data: {str(e)}\u0026#34;) # Log error for debugging return { \u0026#39;statusCode\u0026#39;: 500, \u0026#39;headers\u0026#39;: { \u0026#39;Content-Type\u0026#39;: \u0026#39;application/json\u0026#39;, \u0026#39;Access-Control-Allow-Origin\u0026#39;: \u0026#39;*\u0026#39;, \u0026#39;Access-Control-Allow-Methods\u0026#39;: \u0026#39;GET, POST, OPTIONS\u0026#39;, \u0026#39;Access-Control-Allow-Headers\u0026#39;: \u0026#39;Content-Type, Authorization\u0026#39; }, \u0026#39;body\u0026#39;: json.dumps({ \u0026#39;error\u0026#39;: \u0026#39;Internal server error\u0026#39;, \u0026#39;message\u0026#39;: \u0026#39;Unable to read data from database\u0026#39; }, ensure_ascii=False) } Click Deploy to save the code. You have successfully created the Lambda function for reading data (ReadFunction)! 3. Create Lambda Function for Writing Data (WriteFunction) Choose Create function again. Enter configuration: Function name: WriteFunction Runtime: Python 3.9 Execution role: Choose LambdaDynamoDBRole again Execution role: Choose Use an existing role and select LambdaDynamoDBRole\nCopy the following code and paste it into lambda_function.py:\nimport json import boto3 from datetime import datetime import uuid # Initialize DynamoDB resource dynamodb = boto3.resource(\u0026#39;dynamodb\u0026#39;) table = dynamodb.Table(\u0026#39;HighAvailabilityTable\u0026#39;) def lambda_handler(event, context): # Handle preflight OPTIONS request for CORS if event.get(\u0026#39;httpMethod\u0026#39;) == \u0026#39;OPTIONS\u0026#39;: return { \u0026#39;statusCode\u0026#39;: 200, \u0026#39;headers\u0026#39;: { \u0026#39;Access-Control-Allow-Origin\u0026#39;: \u0026#39;*\u0026#39;, \u0026#39;Access-Control-Allow-Methods\u0026#39;: \u0026#39;GET, POST, OPTIONS\u0026#39;, \u0026#39;Access-Control-Allow-Headers\u0026#39;: \u0026#39;Content-Type, Authorization\u0026#39;, \u0026#39;Access-Control-Max-Age\u0026#39;: \u0026#39;86400\u0026#39; }, \u0026#39;body\u0026#39;: \u0026#39;\u0026#39; } try: # Parse request body if not event.get(\u0026#39;body\u0026#39;): raise ValueError(\u0026#39;Request body is required\u0026#39;) body = json.loads(event[\u0026#39;body\u0026#39;]) # Check if this is a DELETE action if body.get(\u0026#39;Action\u0026#39;) == \u0026#39;DELETE\u0026#39;: # Handle DELETE operation if \u0026#39;ItemId\u0026#39; not in body: raise ValueError(\u0026#39;ItemId is required for delete operation\u0026#39;) item_id = str(body[\u0026#39;ItemId\u0026#39;]).strip() if not item_id: raise ValueError(\u0026#39;ItemId cannot be empty\u0026#39;) # Check if item exists before deleting try: response = table.get_item(Key={\u0026#39;ItemId\u0026#39;: item_id}) if \u0026#39;Item\u0026#39; not in response: raise ValueError(f\u0026#39;Item with ID \u0026#34;{item_id}\u0026#34; not found\u0026#39;) except Exception as e: if \u0026#39;not found\u0026#39; in str(e): raise e else: print(f\u0026#34;Error checking item existence: {str(e)}\u0026#34;) # Delete from DynamoDB table.delete_item(Key={\u0026#39;ItemId\u0026#39;: item_id}) print(f\u0026#34;Successfully deleted item: {item_id}\u0026#34;) # Log for debugging return { \u0026#39;statusCode\u0026#39;: 200, \u0026#39;headers\u0026#39;: { \u0026#39;Content-Type\u0026#39;: \u0026#39;application/json\u0026#39;, \u0026#39;Access-Control-Allow-Origin\u0026#39;: \u0026#39;*\u0026#39;, \u0026#39;Access-Control-Allow-Methods\u0026#39;: \u0026#39;GET, POST, OPTIONS\u0026#39;, \u0026#39;Access-Control-Allow-Headers\u0026#39;: \u0026#39;Content-Type, Authorization\u0026#39; }, \u0026#39;body\u0026#39;: json.dumps({ \u0026#39;message\u0026#39;: f\u0026#39;Successfully deleted item \u0026#34;{item_id}\u0026#34;!\u0026#39;, \u0026#39;itemId\u0026#39;: item_id, \u0026#39;action\u0026#39;: \u0026#39;DELETE\u0026#39;, \u0026#39;timestamp\u0026#39;: datetime.utcnow().isoformat() + \u0026#39;Z\u0026#39; }, ensure_ascii=False) } else: # Handle CREATE/UPDATE operation # Validate required fields if \u0026#39;ItemId\u0026#39; not in body or \u0026#39;Data\u0026#39; not in body: raise ValueError(\u0026#39;ItemId and Data are required fields\u0026#39;) item_id = str(body[\u0026#39;ItemId\u0026#39;]).strip() data = str(body[\u0026#39;Data\u0026#39;]).strip() # Validate input data if not item_id or not data: raise ValueError(\u0026#39;ItemId and Data cannot be empty\u0026#39;) if len(item_id) \u0026gt; 100: raise ValueError(\u0026#39;ItemId cannot exceed 100 characters\u0026#39;) if len(data) \u0026gt; 1000: raise ValueError(\u0026#39;Data cannot exceed 1000 characters\u0026#39;) # Add timestamp and unique identifier for better tracking timestamp = datetime.utcnow().isoformat() + \u0026#39;Z\u0026#39; # Prepare item for DynamoDB item = { \u0026#39;ItemId\u0026#39;: item_id, \u0026#39;Data\u0026#39;: data, \u0026#39;CreatedAt\u0026#39;: timestamp, \u0026#39;UpdatedAt\u0026#39;: timestamp } # Save to DynamoDB table.put_item(Item=item) print(f\u0026#34;Successfully saved item: {item_id}\u0026#34;) # Log for debugging return { \u0026#39;statusCode\u0026#39;: 200, \u0026#39;headers\u0026#39;: { \u0026#39;Content-Type\u0026#39;: \u0026#39;application/json\u0026#39;, \u0026#39;Access-Control-Allow-Origin\u0026#39;: \u0026#39;*\u0026#39;, \u0026#39;Access-Control-Allow-Methods\u0026#39;: \u0026#39;GET, POST, OPTIONS\u0026#39;, \u0026#39;Access-Control-Allow-Headers\u0026#39;: \u0026#39;Content-Type, Authorization\u0026#39; }, \u0026#39;body\u0026#39;: json.dumps({ \u0026#39;message\u0026#39;: \u0026#39;Data has been saved successfully!\u0026#39;, \u0026#39;itemId\u0026#39;: item_id, \u0026#39;timestamp\u0026#39;: timestamp }, ensure_ascii=False) } except json.JSONDecodeError: print(\u0026#34;Error: Invalid JSON in request body\u0026#34;) return { \u0026#39;statusCode\u0026#39;: 400, \u0026#39;headers\u0026#39;: { \u0026#39;Content-Type\u0026#39;: \u0026#39;application/json\u0026#39;, \u0026#39;Access-Control-Allow-Origin\u0026#39;: \u0026#39;*\u0026#39;, \u0026#39;Access-Control-Allow-Methods\u0026#39;: \u0026#39;GET, POST, OPTIONS\u0026#39;, \u0026#39;Access-Control-Allow-Headers\u0026#39;: \u0026#39;Content-Type, Authorization\u0026#39; }, \u0026#39;body\u0026#39;: json.dumps({ \u0026#39;error\u0026#39;: \u0026#39;Invalid JSON format\u0026#39;, \u0026#39;message\u0026#39;: \u0026#39;Request body must be valid JSON\u0026#39; }, ensure_ascii=False) } except ValueError as ve: print(f\u0026#34;Validation error: {str(ve)}\u0026#34;) return { \u0026#39;statusCode\u0026#39;: 400, \u0026#39;headers\u0026#39;: { \u0026#39;Content-Type\u0026#39;: \u0026#39;application/json\u0026#39;, \u0026#39;Access-Control-Allow-Origin\u0026#39;: \u0026#39;*\u0026#39;, \u0026#39;Access-Control-Allow-Methods\u0026#39;: \u0026#39;GET, POST, OPTIONS\u0026#39;, \u0026#39;Access-Control-Allow-Headers\u0026#39;: \u0026#39;Content-Type, Authorization\u0026#39; }, \u0026#39;body\u0026#39;: json.dumps({ \u0026#39;error\u0026#39;: \u0026#39;Validation error\u0026#39;, \u0026#39;message\u0026#39;: str(ve) }, ensure_ascii=False) } except Exception as e: print(f\u0026#34;Unexpected error: {str(e)}\u0026#34;) # Log error for debugging return { \u0026#39;statusCode\u0026#39;: 500, \u0026#39;headers\u0026#39;: { \u0026#39;Content-Type\u0026#39;: \u0026#39;application/json\u0026#39;, \u0026#39;Access-Control-Allow-Origin\u0026#39;: \u0026#39;*\u0026#39;, \u0026#39;Access-Control-Allow-Methods\u0026#39;: \u0026#39;GET, POST, OPTIONS\u0026#39;, \u0026#39;Access-Control-Allow-Headers\u0026#39;: \u0026#39;Content-Type, Authorization\u0026#39; }, \u0026#39;body\u0026#39;: json.dumps({ \u0026#39;error\u0026#39;: \u0026#39;Internal server error\u0026#39;, \u0026#39;message\u0026#39;: \u0026#39;Unable to save data. Please try again later.\u0026#39; }, ensure_ascii=False) } Click Deploy to save the code. You have successfully created 2 Lambda functions named ReadFunction and WriteFunction in the Asia Pacific (Singapore) region with Python 3.9 runtime.\n4. Deploy Functions in Secondary Region Deploy functions in Secondary Region Switch to the backup region (e.g., ap-northeast-1). Repeat steps 2 and 3 to create the same 2 functions (ReadFunction and WriteFunction) in this region. You have successfully created 2 Lambda functions named ReadFunction and WriteFunction in the Asia Pacific (Tokyo) region with Python 3.9 runtime.\n"
},
{
	"uri": "//localhost:1313/6-setup-dns-route53-failover/6.4-route53-health-check-failover/",
	"title": "Route 53 Health check + Failover record (in zone api.turtleclouds.id.vn)",
	"tags": [],
	"description": "",
	"content": "Route 53 Health check + Failover record The final step is to create Health Checks to monitor API endpoint status and configure Failover Records to automatically redirect traffic when the Primary Region encounters issues.\nWhy Health Check and Failover are Needed? Automatic Monitoring: Route 53 continuously checks API endpoint status Instant Failover: Automatically switch to Secondary Region when Primary fails Zero Manual Intervention: No manual intervention required High Availability: Ensure 99.9% uptime for API service Content Create Health Check for Primary Region Create Health Check for Secondary Region Create Failover Record for Primary Create Failover Record for Secondary Test Failover Scenario 1. Create Health Check for Primary Region Access Route 53 → Health checks Choose Create health check Configure Primary Health Check:\nName: Primary Singapore What to monitor: Endpoint Specify endpoint by: Domain name Protocol: HTTPS Domain name: dynw0bc977.execute-api.ap-southeast-1.amazonaws.com/prod/read (API ID of Singapore) Request interval: Fast (10 seconds) Failure threshold: 3 Advanced configuration:\nEnable SNI: Yes Enable health checker regions: 3 regions in Asia Pacific: Asia Pacific (Tokyo) ✅\nAsia Pacific (Singapore) ✅\nAsia Pacific (Sydney) ✅\nImportant: DO NOT use Regional domain of custom domain (d-a7cx5xv22d.execute-api\u0026hellip;) for Health Check as it may cause 403/401 errors. Use invoke URL with API ID instead.\n2. Create Health Check for Secondary Region Choose Create health check again Configure Secondary Health Check:\nName: Secondary Tokyo What to monitor: Endpoint Specify endpoint by: Domain name Protocol: HTTPS Domain name: qp3nkjwlde.execute-api.ap-northeast-1.amazonaws.com/prod/read (API ID of Tokyo) Request interval: Fast (10 seconds)\nFailure threshold: 3 Advanced configuration:\nEnable SNI: Yes Enable health checker regions: 3 regions in Asia Pacific: Asia Pacific (Tokyo) ✅\nAsia Pacific (Singapore) ✅\nAsia Pacific (Sydney) ✅\n3. Create Failover Record for Primary Access Route 53 → Hosted zones Select zone api.turtleclouds.id.vn Choose Create record Configure Primary Failover Record:\nRecord name: leave empty (root of api.turtleclouds.id.vn) Record type: A Alias: Yes Route traffic to: Alias to API Gateway API Choose Region: Asia Pacific (Singapore) Choose API Gateway: Select Singapore API Gateway from dropdown Routing policy: Failover Failover record type: Primary Health check: Select Primary Singapore Record ID: primary-ap-southeast-1 4. Create Failover Record for Secondary Choose Create record again Configure Secondary Failover Record:\nRecord name: leave empty (root of api.turtleclouds.id.vn) Record type: A Alias: Yes Route traffic to: Alias to API Gateway API Choose Region: Asia Pacific (Tokyo) Choose API Gateway: Select Tokyo API Gateway from dropdown Routing policy: Failover Failover record type: Secondary Health check: Select Secondary Tokyo Record ID: secondary-ap-northeast-1 Note: If \u0026ldquo;Alias to API Gateway\u0026rdquo; menu doesn\u0026rsquo;t appear, you can use Record type CNAME pointing directly to the Regional domain of the custom domain API Gateway.\nCheck Health Check Status\nAccess Route 53 → Health checks Check status of both health checks Success status means endpoints are working normally Results After completing this step:\n✅ Health Checks created for both Regions ✅ Failover Records configured ✅ DNS Failover working automatically ✅ Custom Domain api.turtleclouds.id.vn ready ✅ High Availability ensured "
},
{
	"uri": "//localhost:1313/5-setup-api-gateway/",
	"title": "Set Up API Gateway (Both Regions)",
	"tags": [],
	"description": "",
	"content": "Introduction to Amazon API Gateway Amazon API Gateway is a fully managed service that makes it easy for developers to create, publish, maintain, monitor, and secure APIs at any scale. API Gateway acts as a \u0026ldquo;front door\u0026rdquo; for applications to access data, business logic, or functionality from backend services such as AWS Lambda, Amazon EC2, or any web service.\nIn this lab, API Gateway plays a crucial role in the Serverless Failover architecture:\nProvides REST API endpoints: Creates unified endpoints for frontend applications to call Connects with Lambda Functions: Integrates with ReadFunction and WriteFunction created earlier CORS Support: Allows frontend from different domains to access the API Logging and Monitoring: Tracks performance and debugs issues Throttling: Controls the number of requests to protect the backend Benefits of API Gateway in DR Strategy Multi-Region Deployment: Deployed in both Primary and Secondary Regions Health Check Integration: Integrates with Route 53 to check endpoint status Custom Domain: Uses custom domain instead of default AWS URLs SSL/TLS: Automatically supports HTTPS through AWS Certificate Manager Content Create API Gateway in Primary Region Replicate API Gateway to Secondary Region "
},
{
	"uri": "//localhost:1313/6-setup-dns-route53-failover/",
	"title": "Set Up DNS Route 53 and Configure Failover for API Gateway",
	"tags": [],
	"description": "",
	"content": "Set Up DNS Route 53 and Configure Failover for API Gateway In this step, we will configure automatic DNS failover using Amazon Route 53 to ensure high availability for API Gateway. When the Primary Region encounters issues, Route 53 will automatically redirect traffic to the Secondary Region.\nWhy DNS Failover is Needed? Automatic Failover: Automatically redirect traffic when Primary Region fails Health Monitoring: Continuously monitor API endpoint status Zero Manual Intervention: No manual intervention required during failover Custom Domain: Use custom domain instead of default AWS URLs SSL/TLS Security: Ensure HTTPS for all requests DNS Failover Architecture Route 53 Hosted Zone: Manages DNS for subdomain api.turtleclouds.id.vn ACM Certificates: SSL certificates for both Regions Custom Domains: API Gateway custom domains with SSL Health Checks: Monitor API endpoint status Failover Records: Primary/Secondary routing policy Content Set up DNS delegation for api.turtleclouds.id.vn Create ACM DNS validation for both regions Create Custom domains for API Gateway (one per region) Route 53 Health checks + Failover records Important Notes Prerequisites:\nDomain turtleclouds.id.vn managed by Cloudflare API Gateway created in both Regions (Singapore and Tokyo) Lambda Functions working properly DynamoDB Global Tables configured Implementation Process Step 6.1: Create Route 53 Hosted Zone for subdomain api.turtleclouds.id.vn Step 6.2: Request SSL certificates from ACM for both Regions Step 6.3: Create Custom Domain Names for API Gateway Step 6.4: Configure Health Checks and Failover Records Expected Results After completion, you will have:\n✅ Custom Domain: api.turtleclouds.id.vn pointing to API Gateway ✅ SSL/TLS: HTTPS enabled for all requests ✅ Health Monitoring: Route 53 continuously checks API status ✅ Automatic Failover: Automatically switch to Secondary Region when needed ✅ Zero Downtime: Users experience no service interruption "
},
{
	"uri": "//localhost:1313/7-create-frontend-website/",
	"title": "Create the Frontend Website",
	"tags": [],
	"description": "",
	"content": "Step 7: Create the Frontend Website In this step, you will deploy a static frontend website to communicate with the API. The website uses HTML, Bootstrap for UI, and JavaScript to call APIs through Route 53 DNS name.\nWhy Frontend Website is Needed? User Interface: Provide user-friendly interface to test API Real-world Testing: Test failover from end-user perspective Complete Solution: Complete full-stack architecture with frontend + backend Demonstration: Illustrate integration with API Gateway through custom domain Content Download source code from GitHub Create S3 Bucket Edit API configuration Upload files to S3 Enable Static Website Hosting Configure Public Access Block Configure Public Objects (Object ACLs) Test Website 1. Download source code from GitHub Clone or download repository directly: 👉 Front-end-Workshop-Failover: https://github.com/quywork62/Front-end-Workshop-Failover-\nIf using git:\ngit clone https://github.com/quywork62/Front-end-Workshop-Failover-.git Or download ZIP file and extract.\n2. Create S3 Bucket Access Amazon S3 → Create bucket Bucket name: api.turtleclouds.id.vn (Bucket name must exactly match the domain you will use to host the website) Region: select ap-southeast-1 (Singapore) Keep other default options → Choose Create bucket 3. Edit API configuration In the source code, find the main JavaScript file (e.g., in index.html) and edit:\nconst apiUrl = \u0026#39;https://api.\u0026lt;YOUR-DOMAIN\u0026gt;\u0026#39;; // Use Route 53 DNS name ---\u0026gt; const apiUrl = \u0026#39;https://api.turtleclouds.id.vn/prod\u0026#39;; // Use Route 53 DNS name pointing to API Gateway Note: Ensure the API URL points to the domain configured in Route 53, not the regional domain names of API Gateway.\n4. Upload files to S3 Go to bucket api.turtleclouds.id.vn → Upload Select all code files (HTML, CSS, JS, images) from the project folder Click Upload 5. Enable Static Website Hosting Go to bucket → Properties tab Scroll down to Static website hosting section → Choose Edit Configuration:\nStatic website hosting: Enable Hosting type: Host a static website Index document: index.html Click Save changes 👉 After enabling, you will see the website endpoint provided by S3:\nhttp://api.turtleclouds.id.vn.s3-website-ap-southeast-1.amazonaws.com 6. Configure Public Access Block By default, S3 blocks public access. Need to disable it to allow website access:\nGo to bucket → Permissions tab Block public access (bucket settings) section → Choose Edit Uncheck \u0026ldquo;Block all public access\u0026rdquo; Choose Save changes → Confirm Confirm Warning: Only disable public access block for buckets containing static websites. Do not apply to buckets containing sensitive data.\n7. Configure Public Objects (Object ACLs) a. Enable ACLs in Object Ownership\nGo to bucket → Permissions tab Access controls list(ACLs) section → bucket owner enforced Select:\nACLs enabled Bucket owner preferred Check \u0026ldquo;I acknowledge\u0026hellip;\u0026rdquo; Click Save changes 👉 After that you will see status: Object Ownership = Bucket owner preferred (ACLs enabled)\nb. Make frontend files public\nGo to Objects tab → Select all website files (HTML, CSS, JS, images) Click Actions → Make public using ACL Confirm with Make public 👉 Now, static files are public and can be accessed directly via URL.\n8. Test Website Test Static Website Endpoint:\nhttp://api.turtleclouds.id.vn.s3-website-ap-southeast-1.amazonaws.com Test Direct S3 URL:\nhttps://s3.ap-southeast-1.amazonaws.com/api.turtleclouds.id.vn/index.html Results After completing this step:\n✅ S3 Bucket created and configured ✅ Static Website Hosting enabled ✅ Frontend Code uploaded and made public ✅ Website accessible via S3 endpoint ✅ API Integration working with Route 53 domain Troubleshooting If website doesn\u0026rsquo;t load:\nCheck Block public access is disabled Verify Object ACLs are set to public Ensure index.html exists in bucket root If API calls fail:\nCheck CORS configuration on API Gateway Verify Route 53 records have propagated Test API endpoint directly with curl Preparation for Next Step The frontend website is now ready to test the entire high availability architecture. You can test failover scenarios and monitor health checks from the user interface.\n"
},
{
	"uri": "//localhost:1313/8-test-failover-delete-primary-api/",
	"title": "Test failover mechanism by deleting primary API (Singapore)",
	"tags": [],
	"description": "",
	"content": "In this step, we will completely delete the API in Singapore region (ap-southeast-1) to verify the failover mechanism to the Secondary region (Tokyo).\n⚠️ Important Note: This action cannot be undone if you haven\u0026rsquo;t exported the API. Therefore, export before deleting to be able to restore later.\nWhy Test Failover is Needed? Validate Architecture: Verify that the failover mechanism works correctly Real-world Simulation: Simulate real-world scenarios when Primary Region fails Business Continuity: Ensure service is not interrupted Confidence Building: Build confidence in the High Availability system Content (Optional) Export API Delete Domain Mapping (if any) Delete API on Console Check Health Check (Route 53) Verify Failover 1. (Optional) Export API Navigate to API Gateway → APIs → select HighAvailabilityAPI Go to Stages → select prod Choose Export to download Swagger/OpenAPI definition file 👉 Save this file to restore or redeploy the API if needed.\n2. Delete Domain Mapping (if any) Some AWS accounts require removing domain mapping before deleting API.\nSteps:\nGo to Custom domain names → select domain Choose Delete API mapping 3. Delete API on Console Return to APIs → select HighAvailabilityAPI Choose Actions → Delete Type delete to confirm Or via AWS CLI:\nGet list of APIs in Singapore:\naws apigateway get-rest-apis --region ap-southeast-1 Delete API:\naws apigateway delete-rest-api \\ --rest-api-id \u0026lt;API_ID\u0026gt; \\ --region ap-southeast-1 4. Check Health Check (Route 53) After Singapore API is deleted, Primary health check will report Unhealthy (HTTP 404/403).\nRoute 53 will automatically failover all traffic to Secondary (Tokyo – ap-northeast-1).\nAccess Route 53 → Health checks Check status of Primary Singapore health check Status will change from Success → Failure Check Frontend Website:\nWhile waiting for health check to detect failure, you can test the frontend website to see the changes:\nAccess frontend website: http://api.turtleclouds.id.vn.s3-website-ap-southeast-1.amazonaws.com Try CRUD functions Initially may encounter errors when Singapore API was just deleted After 2-3 minutes, website will work normally again when traffic is switched to Tokyo Note: Health check may take 2-3 minutes to detect failure and trigger failover.\n5. Verify Failover Method 1: Test directly in Route 53\nGo to Route 53 Console → Hosted zones → select domain api.turtleclouds.id.vn Click Test record Enter:\nRecord name: api.turtleclouds.id.vn Record type: A Click Test 👉 If failover is successful, record will resolve to IP in Tokyo (ap-northeast-1) instead of Singapore.\nMethod 2: Verify actual IP\nCheck DNS/IP from terminal:\ndig api.turtleclouds.id.vn Or on Windows PowerShell:\nResolve-DnsName api.turtleclouds.id.vn 👉 Result will show IP list (e.g., 35.74.x.x, 52.199.x.x, 52.193.x.x) — all belonging to Tokyo region.\nMethod 3: Reverse DNS to identify Region\nOn Linux/Mac:\nhost \u0026lt;IP\u0026gt; On Windows PowerShell:\nResolve-DnsName \u0026lt;IP\u0026gt; -Type PTR 👉 If result shows ap-northeast-1 (Tokyo) → proves failover successful. 🎉\nExpected Results ✅ API in Singapore has been deleted\n✅ Health check changed to Unhealthy\n✅ Route 53 failover to Tokyo (ap-northeast-1)\n✅ Accessing domain api.turtleclouds.id.vn will return response from Tokyo API\nMonitoring and Verification CloudWatch Metrics:\nRoute 53 Health Check status changes API Gateway request metrics (should show 0 for Singapore, increased for Tokyo) Lambda invocation metrics shift to Tokyo region Timeline Expectations:\n0-2 minutes: API deletion completed 2-5 minutes: Health check detects failure 5-7 minutes: DNS failover propagation 7+ minutes: All traffic routed to Tokyo Troubleshooting If failover doesn\u0026rsquo;t work:\nCheck Health Check configuration Verify Failover records setup correctly Check DNS TTL settings Ensure Tokyo API and Lambda functions work normally If you want to restore Singapore API:\nImport API from exported file Redeploy Lambda functions Recreate Custom Domain mapping Wait for Health Check to recover Conclusion You have successfully verified that the Serverless Failover mechanism works automatically and effectively. The system has the ability to:\nAutomatically detect failures through Route 53 Health Checks Switch traffic to backup Region within 5-7 minutes Maintain service continuity without manual intervention Ensure data consistency thanks to DynamoDB Global Tables Congratulations! You have successfully built a High Availability Serverless architecture with fault tolerance and automatic recovery capabilities.\n"
},
{
	"uri": "//localhost:1313/9-clean-up-resources/",
	"title": "Clean Up Resources",
	"tags": [],
	"description": "",
	"content": "Step 9: Clean Up Resources After successfully testing the HA/DR \u0026amp; Failover mechanism, you need to delete the AWS resources created to avoid incurring costs.\n⚠️ Warning: Resource deletion is irreversible. Make sure you have backed up/exported everything necessary before proceeding.\nWhy Clean Up is Needed? Cost Optimization: Avoid unnecessary costs Resource Management: Keep AWS account clean Security: Remove unused endpoints and resources Best Practice: Good habit in cloud resource management Content Delete API Gateway (Secondary – Tokyo) Delete DynamoDB Global Tables Delete Lambda Functions Delete Route 53 Health Checks \u0026amp; DNS Records Delete ACM Certificates Delete S3 Bucket (Frontend Website) Delete IAM Roles 1. Delete API Gateway (Secondary – Tokyo) Step 1: Delete Custom Domain Mapping (if any)\nGo to API Gateway in Tokyo (ap-northeast-1) region Select Custom domain names → select api.turtleclouds.id.vn API mappings tab → Delete API mapping Step 2: Delete API Gateway\nReturn to APIs → select HighAvailabilityAPI Choose Actions → Delete Type delete to confirm Step 3: Delete Custom Domain\nGo to Custom domain names → select api.turtleclouds.id.vn Choose Actions → Delete domain name Type domain name to confirm CLI (optional):\n# Get list of APIs aws apigateway get-rest-apis --region ap-northeast-1 # Delete API mapping first aws apigateway delete-base-path-mapping \\ --domain-name api.turtleclouds.id.vn \\ --base-path \u0026#34;\u0026#34; \\ --region ap-northeast-1 # Delete API aws apigateway delete-rest-api --rest-api-id \u0026lt;API_ID\u0026gt; --region ap-northeast-1 # Delete custom domain aws apigateway delete-domain-name \\ --domain-name api.turtleclouds.id.vn \\ --region ap-northeast-1 Note: API Gateway in Singapore was already deleted in the previous failover test step.\n2. Delete DynamoDB Global Tables Step 1: Delete Global Table Replicas\nGo to DynamoDB in Tokyo (ap-northeast-1) region Select HighAvailabilityTable Global Tables tab → Delete replica Step 2: Delete Primary Table\nSwitch to Singapore (ap-southeast-1) region Select HighAvailabilityTable Actions → Delete table Type delete to confirm CLI (optional):\n# Delete replica in Tokyo aws dynamodb delete-table --table-name HighAvailabilityTable --region ap-northeast-1 # Delete primary table in Singapore aws dynamodb delete-table --table-name HighAvailabilityTable --region ap-southeast-1 3. Delete Lambda Functions Delete Lambda Functions in Tokyo:\nGo to Lambda in Tokyo (ap-northeast-1) region Delete functions: ReadFunction WriteFunction DeleteFunction Delete Lambda Functions in Singapore:\nGo to Lambda in Singapore (ap-southeast-1) region Delete similar functions (if any remain) CLI (optional):\n# Tokyo aws lambda delete-function --function-name ReadFunction --region ap-northeast-1 aws lambda delete-function --function-name WriteFunction --region ap-northeast-1 aws lambda delete-function --function-name DeleteFunction --region ap-northeast-1 # Singapore aws lambda delete-function --function-name ReadFunction --region ap-southeast-1 aws lambda delete-function --function-name WriteFunction --region ap-southeast-1 aws lambda delete-function --function-name DeleteFunction --region ap-southeast-1 4. Delete Route 53 Health Checks \u0026amp; DNS Records Step 1: Delete Health Checks\nGo to Route 53 Console → Health checks Delete health checks: Primary Singapore Secondary Tokyo Step 2: Delete DNS Records\nGo to Hosted zones → api.turtleclouds.id.vn Delete failover records: Primary failover record Secondary failover record ACM validation CNAME records Step 3: Delete Hosted Zone (optional)\nIf no longer needed, you can delete the hosted zone api.turtleclouds.id.vn Actions → Delete hosted zone Warning: Only delete hosted zone if you\u0026rsquo;re sure you won\u0026rsquo;t use the api.* subdomain anymore.\n5. Delete ACM Certificates Delete Certificate in Singapore:\nGo to AWS Certificate Manager (ACM) in Singapore (ap-southeast-1) region Select certificate api.turtleclouds.id.vn Actions → Delete Delete Certificate in Tokyo:\nGo to ACM in Tokyo (ap-northeast-1) region Delete similar certificate Note: Certificates can only be deleted when they are not being used by any resources.\n6. Delete S3 Bucket (Frontend Website) Step 1: Empty Bucket\nGo to S3 Console → bucket api.turtleclouds.id.vn Select Empty bucket Type permanently delete to confirm Step 2: Delete Bucket\nAfter emptying, select Delete bucket Type bucket name to confirm CLI (optional):\n# Empty bucket aws s3 rm s3://api.turtleclouds.id.vn --recursive # Delete bucket aws s3 rb s3://api.turtleclouds.id.vn 7. Delete IAM Roles Go to IAM Console → Roles Delete roles created for Lambda: HighAvailabilityLambdaRole Other project-related roles CLI (optional):\n# Detach policies first aws iam detach-role-policy --role-name HighAvailabilityLambdaRole --policy-arn arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole # Delete role aws iam delete-role --role-name HighAvailabilityLambdaRole Clean Up Checklist After completion, check:\n✅ API Gateway (both Singapore and Tokyo) deleted ✅ DynamoDB Global Tables completely deleted ✅ Lambda Functions in both regions deleted ✅ Route 53 Health Checks deleted ✅ Route 53 DNS Records deleted ✅ ACM Certificates in both regions deleted ✅ S3 Bucket and contents deleted ✅ IAM Roles no longer needed deleted Conclusion You have successfully deleted all AWS resources created in this lab. This helps:\nAvoid unnecessary costs Keep AWS account clean Apply best practices in cloud resource management Complete the cycle of development and testing Complete! You have successfully cleaned up all resources and completed the Serverless Failover Architecture lab.\n"
},
{
	"uri": "//localhost:1313/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "//localhost:1313/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]